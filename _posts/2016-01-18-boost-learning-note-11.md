---
layout: post
title: "boost 学习笔记 10：设计模式"
tagline: ""
description: ""
category: 学习笔记
tags: [boost, C++]
last_updated: 
---

设计模式是一个面向对象的通用解决方案，是一套被反复使用，多数人知晓的代码设计经验总结。

一般分为：创建型模式、机构型模式和行为模式

## 创建型模型

### 抽象工厂 Abstract Factory
提供统一的创建接口。

### 生成器  Builder
将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。

### 工厂方法
定义接口用于创建对象。

### 原型 Prototype
原型模式使用类的实例通过拷贝的方式创建对象，具体的拷贝行为可以定制。最常见的用法为类实现一个 clone() 成员函数，这个函数创建一个与原型相同或者相似的新对象。

### 单件 Singleton
运行时，类有且仅有一个实例。

## 结构性模型

如何组合类或者对象，更而形成更大更有用的新对象。

### 适配器 Adapter
把一个类的接口转换成另一个接口，在不改变原有代码的基础上复用原代码。

### 桥接 Bridge
将抽象部分与实现部分分离，使它们都可以独立的变化。

### 组合 Composite
将小对象组合成树形结构。

### 装饰 Decorator
运行时动态地给对象增加功能。

### 外观 Facade
为系统中大量对象提供一个一致的对外接口，简化系统使用。

### 享元 Flyweight
使用共享的方式节约内存的使用

### 代理 Proxy
它的意图不是改变接口插入新系统（适配），也不是为对象增加职责（装饰），而是要控制对象。

智能指针库，利用代理模式将原始指针包装，代理原始指针的职能。

## 行为模式

### 职责链 Chain of Responsibility
把对象连成一条链，使链上的每个对象都有机会处理请求。

### 命令 Command
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。

### 解释器 Interpreter
给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。

### 迭代器 Iterator
提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。

### 中介者 Mediator
包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。

### 备忘录 Memento
备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。

### 观察者 Observer
定义对象间一对多的联系，当一个对象的状态发生变化时，所有与它有联系的观察者对象都会得到通知。

### 状态 State
允许对象在状态发生变化时行为也同时发生改变。

### 策略 Strategy
封装不同的“算法”，使它们可以在运行时相互替换。

### 模板 Template method
模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。

### 访问者 Visitor
分离类的内部元素和访问它们的操作，可以在不改变内部元素的情况下增加作用于它们的新操作。

## 其他模式

### 空对象
用于返回无意义的对象时，它可以承担处理null的责任。

### 包装外观
通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，这样无疑会降低应用程序的复杂度，并且提高了程序的可维护性。

### 前摄器模式 Proactor
用于为异步事件多路分离和分派处理器的对象行为模式

